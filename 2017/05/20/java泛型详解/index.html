<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Vic7or,455036517@qq.com"><title>java泛型详解 · Forever Young</title><meta name="description" content="泛型[TOC]
泛型出现的原因：​    比如说小明在工作中，因为需要调用数据库的相关数据，就产生了对应的数据对象。猫1，猫2，猫3,而从数据库获取的结果集后，小明需要用主键和对象产生映射关系，于是小明建立了一个容器类，用来装入ID和猫对象的映射关系，小明称之为CatMap。CatMap是基于原生的"><meta name="keywords" content="Hexo,java,php,html.Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Forever Young</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="http://github.com/https://github.com/mzenm"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>java泛型详解</a></h3></div><div class="post-content"><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>[TOC]</p>
<h2 id="泛型出现的原因："><a href="#泛型出现的原因：" class="headerlink" title="泛型出现的原因："></a>泛型出现的原因：</h2><p>​    比如说小明在工作中，因为需要调用数据库的相关数据，就产生了对应的数据对象。猫1，猫2，猫3,而从数据库获取的结果集后，小明需要用主键和对象产生映射关系，于是小明建立了一个容器类，用来装入ID和猫对象的映射关系，小明称之为CatMap。CatMap是基于原生的数组实现Cat[]，通过对对应ID作为数组的索引实现了基本的映射关系，在通用类中使用hash值作为元素的键。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.hash.hashcode;</div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatMap</span> </span>&#123;</div><div class="line">	<span class="comment">//设置默认容量</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INIT_CAPTIVE = <span class="number">1</span>;</div><div class="line">	<span class="comment">//设置当先用数据达到总容量的0.75时进行扩容</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> BOOM_INIT_CAPTIVE = <span class="number">0.75</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span>  <span class="keyword">int</span> captive;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">double</span> limit;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Cat[] cats;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CatMap</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.captive = INIT_CAPTIVE;</div><div class="line">		<span class="keyword">this</span>.limit = BOOM_INIT_CAPTIVE;</div><div class="line">		cats = <span class="keyword">new</span> Cat[captive];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> Cat <span class="title">put</span><span class="params">(<span class="keyword">int</span> id, Cat cat)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(cats == <span class="keyword">null</span>)&#123;</div><div class="line">			<span class="keyword">while</span>(captive*limit&lt;id)&#123;</div><div class="line">				captive&lt;&lt;=<span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">			cats=Arrays.copyOf(cats, captive);</div><div class="line">			cats[id] = cat;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(cats.length-<span class="number">1</span>&lt;id)&#123;</div><div class="line">			<span class="keyword">while</span>(captive*limit&lt;id)&#123;</div><div class="line">				captive&lt;&lt;=<span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">			cats=Arrays.copyOf(cats, captive);</div><div class="line">			cats[id] = cat;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			Cat oldTarget = cats[id];</div><div class="line">			cats[id] = cat;</div><div class="line">			<span class="keyword">return</span> oldTarget;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> Cat <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(captive&lt;=id)&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> cats[id];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Cat[] values()&#123;</div><div class="line">		<span class="keyword">return</span> cats;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		CatMap cats = <span class="keyword">new</span> CatMap();</div><div class="line">		Cat cat1 = <span class="keyword">new</span> Cat(<span class="string">"blue"</span>);</div><div class="line">		cats.put(<span class="number">100</span>, cat1);</div><div class="line">		Cat cat2 = <span class="keyword">new</span> Cat(<span class="string">"black"</span>);</div><div class="line">		cats.put(<span class="number">1000</span>, cat2);</div><div class="line">		System.out.println(cats.get(<span class="number">100</span>));</div><div class="line">		System.out.println(cats.get(<span class="number">1000</span>));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    然而在后续的继续实践中，小明发现他还要建立狗,马等映射关系，小明又得继续建立对象的映射关系，DogMap,HorseMap等，这种情况下，小明就试图用统一的方式标示这种映射关系。因为JAVA中所有类都是Object类的子类，于是小明抽象出一个ObjectMap容器类来统一存放这种映射关系，而在取出时再将其转换成对应的关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.hash.hashcode;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectMap</span> </span>&#123;</div><div class="line">  <span class="comment">//设置默认容量</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INIT_CAPTIVE = <span class="number">1</span>;</div><div class="line">  <span class="comment">//设置当先用数据达到总容量的0.75时进行扩容</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> BOOM_INIT_CAPTIVE = <span class="number">0.75</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>  <span class="keyword">int</span> captive;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">double</span> limit;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> Object[] objects;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ObjectMap</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.captive = INIT_CAPTIVE;</div><div class="line">    <span class="keyword">this</span>.limit = BOOM_INIT_CAPTIVE;</div><div class="line">    objects = <span class="keyword">new</span> Object[captive];</div><div class="line">  &#125;</div><div class="line">  ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    程序运行了一段时间后，还是出了问题，一方面小明需要使用非整形作为键，这样作为原来使用数组作为处理的方式就不要合适了；另一方面，因为使用Object的方法来书写，导致必须在ObjectMap中对类型进行判断，防止在同一个容器中插入不同的类型对象，当取出Object时又必须转换成真正需要的类型进行操作，于是错误产生了。于是小明想是不是可以将类型给提取出来，作为参数出现，这样既能确保传入参数的类型一致性，也能保证取出的结果已经是转换后的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectMap</span> </span>&#123;</div><div class="line">  	.....</div><div class="line">	</div><div class="line">	<span class="keyword">private</span>  <span class="keyword">int</span> captive;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">double</span> limit;</div><div class="line">	<span class="keyword">private</span> Class keyType1;</div><div class="line">    <span class="keyword">private</span> Class ValueType;</div><div class="line">    ......</div><div class="line">    <span class="comment">//类型检查</span></div><div class="line">    <span class="comment">//类型转换</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectMap</span><span class="params">(captive,limit,keyType1,ValueType)</span></span>&#123;</div><div class="line"> 		......     </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    这样在建立对应的类容器时，就需要将类的类型放入到构造函数中，用来确保出传入类的一致性和获取数据时获取到类型转换之后的类型结果。确保结果的一致性。而在小明后续的工作中，出现了其他一些具有统一方法特征但根据不同类需要就建立相同属性和方法的对象，于是提取出了泛型的概念，用来表示类型参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//编译器自动完成类型转换</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectMap</span>&lt;<span class="title">T</span>,<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  	.....</div><div class="line">	</div><div class="line">	<span class="keyword">private</span>  <span class="keyword">int</span> captive;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">double</span> limit;</div><div class="line">    ......</div><div class="line">    <span class="comment">//类型检查</span></div><div class="line">    <span class="comment">//类型转换</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectMap</span><span class="params">(captive,limit)</span></span>&#123;</div><div class="line"> 		......     </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    可以认为，泛型对象所映射的类在运行期应该是同一类。但在编译期的确应该具有独立型，泛型可以认为是一次对类的再次抽象。这种情况下，如果一个对象和他的遥控器变量对应的类型参数不同，那意味这在对象接收到某消息后，对消息体中进行类型检查和类型转换可能会出问题。</p>
<hr>
<p>​    泛型类是一个类的模板，需要制定泛型类实现一个类，即一张蓝图，而后再实例化这张蓝图，获得一个实际的对象。</p>
<p>​    一个合适的比喻是这样的，小王是一个电脑城装计算机的，他现在要装配一台主机，但是客户需要一个具备顶尖显卡的机型，但是现在市场上这几个显卡产品都没有，能有什么基本碰运气。但是小王知道这些显卡的基本接口和装配方式基本一样。一旦市场上有任何一种显卡到货，那么计算机的组合也就确认了。果然，不久之后，市场上有货了，小王拿到一个七彩虹的1080GTX，然后根据之前的设计成功完成客户机的装配。</p>
<h2 id="泛型类概述"><a href="#泛型类概述" class="headerlink" title="泛型类概述"></a>泛型类概述</h2><ul>
<li>泛型 术语：适用于多种类型</li>
<li>泛型 本质：类型参数化</li>
<li>泛型 核心：通知编译器需要的类型，编译器处理同意传入，类型转化等信息。</li>
<li><p>泛型 初衷：</p>
<ul>
<li><p>希望类或方法可以具备最广泛的表达能力，即通过解耦类和方法 与 类型 之间的约束;类和方法不再与调用类型绑定；</p>
</li>
<li><p>对于容器类而言，泛型在保证容器类可以存储任何类型对象的同事，又保证了容器类一旦声明自己要保存的元素类型，就不再保存其他类型的元素了。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>简单而言: 泛型 = 编译时的类型检查 + 编译时的类型擦除（编译器插入checkcast等）+ 运行时的自动类型转换</p>
<p>类型参数推断，当时用泛型类时，必须在创建对象的时候指定类型参数的值;而是用泛型方法时，通常不必指明参数类型（应该是编译器自动将实参类型作为参数类型），但是如果返回值也是泛型时，一般必须指定返回值的泛型类型才能保证正常的计算过程</p>
</blockquote>
<h2 id="泛型的定义和语法"><a href="#泛型的定义和语法" class="headerlink" title="泛型的定义和语法"></a>泛型的定义和语法</h2><ul>
<li><p>泛型类 （参数化类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>泛型接口 （参数化接口）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>泛型方法 （参数化方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span></span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="泛型的注意事项"><a href="#泛型的注意事项" class="headerlink" title="泛型的注意事项"></a>泛型的注意事项</h2><ul>
<li><p>多态和泛型的权衡</p>
<p>​    如果你希望你使用的<code>类型参数</code>只是一个类以及他的子类型，那么使用明确的类型定义即可，多态完全可以实现。如果你想让你的<code>类型参数</code>支持更加广泛的类型时，再使用泛型更加合理。容器类就是典型的使用场景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HasF</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;...&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//泛型实现</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator1</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt;</span>&#123;</div><div class="line">  <span class="keyword">private</span> T obj;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manipulator1</span><span class="params">(T x)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.obj = x;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span></span>&#123;</div><div class="line">    obj.f();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//多态实现</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator2</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> HasF obj;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manipulator2</span><span class="params">(HasF x)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.obj = x;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span></span>&#123;</div><div class="line">    obj.f();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>泛型类误区：</p>
<p>如果某类继承自某泛型类，但是类名后未跟随泛型类名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一段代码</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> T first;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.first = first;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.first = first;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> first;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 时间间隔类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DateInterval</span><span class="params">(Date first)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(first);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Date second)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.setFirst(second);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getFirst</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getFirst();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    由泛型类的定义可知，<code>Pair&lt;T&gt;</code> 是一个泛型类，因为在类名后面有类型参数；类<code>DateInterval</code>后面没有跟类型参数列表，因此该类就是一个 T 被替换为 Date 的实体类，其从 <code>Pair&lt;Date&gt;</code>泛型类型 继承得到的方法列表，与泛型彻底无关。</p>
<p>​</p>
</li>
<li><p>在泛型类中， static 域或方法无法访问泛型类的类型参数；若静态方法需要使用泛型能力，就必须使其成为泛型方法（不与泛型类共享类型参数）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T one;   <span class="comment">//编译错误   </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  T <span class="title">show</span><span class="params">(T one)</span></span>&#123;   <span class="comment">//编译错误    </span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;    </div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是下列重新定义另一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">show</span><span class="params">(T one)</span></span>&#123;<span class="comment">//这是正确的    </span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;    </div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为这是一个<code>泛型方法</code>，在泛型方法中使用的 <code>类型参数T</code> 是自己在方法中定义的<code>T</code>，而不是泛型类中的 T。</p>
<p>​</p>
</li>
<li><p>限制泛型可用的类型</p>
<ul>
<li><p>如果想要限制使用泛型的类别时，即要求只能使用某个特定类型或者其子类型才能实例化该类型时，使用 extends 关键字指定这个类型必须是继承或者实现某个接口。一般地，当没有指定泛型继承的类型或实现的接口时，默认等价于使用 <code>T extends Object</code>，因此，默认情形下任何类型都可以作为参数插入</p>
</li>
<li><p>特别地，为类型参数设定的<strong>第一个边界可以是类类型或接口类型,类型参数的第一个边界之后的任意额外边界都只能是接口类型，同时，一般将标记性接口放到靠后位置,这些类型参数之间有 &amp; 相连接</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">publc <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Serilizable</span>&gt;</span>&#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
<li><p>在调用泛型方法的时候，可以指定泛型，也可以不指定泛型</p>
<p>​    在不指定泛型（类型参数）的情况下，泛型变量的类型为该方法中的几个类型的同一个父类的最小集，直到Object.该方法中的几种类型必须是该泛型实例类型或者其子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//代码示例</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line"></div><div class="line">        <span class="comment">/**不指定泛型的时候*/</span>  </div><div class="line">        Integer i = Test2.add(<span class="number">1</span>, <span class="number">2</span>);   <span class="comment">//这两个参数都是Integer，所以T为Integer类型  </span></div><div class="line">        Number f = Test2.add(<span class="number">1</span>, <span class="number">1.2</span>);  <span class="comment">//这两个参数一个是Integer，一个是Double，所以取同一父类的最小级，为Number  </span></div><div class="line">        Object o = Test2.add(<span class="number">1</span>, <span class="string">"asd"</span>);  <span class="comment">//这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object  </span></div><div class="line"></div><div class="line">        System.out.println(i.getClass().getName());   <span class="comment">//输出： java.lang.Integer</span></div><div class="line">        System.out.println(f.getClass().getName());   <span class="comment">//输出： java.lang.Double</span></div><div class="line">        System.out.println(o.getClass().getName());   <span class="comment">//输出： java.lang.String</span></div><div class="line"></div><div class="line">        <span class="comment">/**指定泛型的时候*/</span>  </div><div class="line">        <span class="keyword">int</span> a = Test2.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">//指定了Integer，所以只能为Integer类型或者其子类  </span></div><div class="line">        <span class="keyword">int</span> b = Test2.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2.2</span>);  <span class="comment">//编译错误，指定了Integer，不能为Double</span></div><div class="line">        Number c = Test2.&lt;Number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>);  <span class="comment">//指定为Number，所以可以为Integer和Double  </span></div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="comment">//这是一个简单的泛型方法  </span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">add</span><span class="params">(T x,T y)</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> y;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>注意，这个例子中的两个输出是java.lang.Double和java.lang.String，而不是java.lang.Number和java.lang.Object:</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">System.out.println(f.getClass().getName());   <span class="comment">//输出： java.lang.Double</span></div><div class="line"></div><div class="line">System.out.println(o.getClass().getName());   <span class="comment">//输出： java.lang.String</span></div></pre></td></tr></table></figure>
<p><em>实际上，这个问题涉及泛型机制和多态两点。在例子中，类型参数T被编译器用Number替换，这是没问题的，因为无论整形还是浮点型都属于数型，这是由多态机制保证的。但是，无论x还是y，它们本质上还是各自的类型不会发生任何改变。要注意的是，这里的getClass()方法返回的变量的实际类型，即运行时类型而非编译时类型，因此返回y的类型是double而非number。</em></p>
<p>​</p>
</li>
<li><p>泛型的兼容性</p>
<ul>
<li><p><strong>从泛型类型生成的任何类型的引用都能存储到对应的原生类型的变量中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LinkedList list = <span class="keyword">new</span> LinkedList&lt;String&gt;();</div><div class="line"><span class="comment">//等价于</span></div><div class="line">LinkedList list = <span class="keyword">new</span> LinkedList();</div></pre></td></tr></table></figure>
</li>
<li><p><strong>从原生类型生成的引用能存储到任何类型的泛型类型的变量中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LinkedList&lt;String&gt; list1 = <span class="keyword">new</span> LinkedList();</div><div class="line">LinkedList&lt;Integer&gt; list2 = <span class="keyword">new</span> LinkedList();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>​</p>
</li>
<li><p>primitive类型不可以作为类型参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LinkedList&lt;<span class="keyword">int</span>&gt; list = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>&gt;(); </div><div class="line"><span class="comment">// You are trying to pass a primitive object into a generic type declaration whereas generic types always expect a Wrapper Class object.</span></div></pre></td></tr></table></figure>
<p> 泛型 = 编译时的类型检查 + 编译时的类型擦除（编译器插入checkcast等）+ 运行时的自动类型转换.而基础类型无法完成类型的检查，擦除和转换，所以必须使用</p>
<p>​</p>
</li>
<li><p>若使用泛型方法可以取代将整个类泛型化，那么就应该使用泛型方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CityManager</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Leader</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">(K l)</span></span>&#123;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beat</span><span class="params">(V v)</span></span>&#123;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完全等价于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CityManager</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">(Leader l)</span></span>&#123;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> &lt;V&gt; <span class="function"><span class="keyword">void</span> <span class="title">beat</span><span class="params">(V v)</span></span>&#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>泛型方法与可变参数列表可以很好的共存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T... args)</span></span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="通配符及泛型的逆变和协变"><a href="#通配符及泛型的逆变和协变" class="headerlink" title="通配符及泛型的逆变和协变"></a>通配符及泛型的逆变和协变</h2><ol>
<li><p>通配符</p>
<p>无界通配符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;?&gt; list  = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">list  = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</div><div class="line"></div><div class="line">list.add(e);     <span class="comment">// e cannot be resolved to a variable  </span></div><div class="line">System.out.println(list1.size());   <span class="comment">// OK</span></div></pre></td></tr></table></figure>
<p>​    在 Java 集合框架中，对于参数值是未知类型的容器类，只能读取其中元素，不能向其中添加元素， 因为，其类型未知，所以编译器无法识别添加元素的类型和容器的类型是否兼容，唯一的例外是 NULL(对 Null 而言，无所谓类型)。</p>
<ul>
<li><p>List ： 持有任何Object类型 的 <strong>原生List</strong>，编译器不会对原生类型进行安全检查；类型会被完全擦除，可以存入任何类型，取出的类型都是Object，都最终指向</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ArrayList list = <span class="keyword">new</span> ArrayList(); <span class="comment">//这种情况下 类型参数 都认为是Object</span></div><div class="line">ArrayList list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">ArrayList list = <span class="keyword">new</span> ArrayList&lt;Leader&gt;();</div><div class="line">list.add(<span class="string">"121"</span>);</div><div class="line">list.add(<span class="keyword">new</span> ArrayList());</div><div class="line">String a = list.get(<span class="number">0</span>); <span class="comment">//编译错误，返回类型Object</span></div><div class="line">System.out.println(list.get(<span class="number">0</span>).getClass().getName());  <span class="comment">//输出java.lang.String</span></div><div class="line">System.out.println(list.get(<span class="number">1</span>).getClass().getName());  <span class="comment">//java.util.ArrayList</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>List&lt;?&gt;</code> ：具有某种特定类型 的 <strong>非原生List</strong>，编译器会进行安全检查；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;?&gt; list1 = <span class="keyword">new</span> ArrayList();</div><div class="line">ArrayList&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">list.add(<span class="keyword">null</span>); 		<span class="comment">//仅可以加入null</span></div><div class="line">list.add(<span class="string">"aa"</span>);			<span class="comment">//编译错误The method add(capture#2-of ?) in the type ArrayList&lt;capture#2-of ?&gt; is not applicable for the arguments (String)</span></div><div class="line">Object object = list.get(<span class="number">0</span>);</div></pre></td></tr></table></figure>
</li>
<li><p><code>List&lt;Object&gt;</code> ： 编译器认为 <code>List&lt;Object&gt;</code> 是 <code>List&lt;?&gt;</code> 的子类型； </p>
</li>
</ul>
<p>​</p>
</li>
<li><p>向上转型 / 通配符的上界 / 协变</p>
<p>在引入通配符的上界这一概念时，我们先看一下数组的一种特殊行为：<strong>基类型的数组引用可以被赋予导出类型的数组</strong>,如下面的代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125; </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125; </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125; </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125; </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantArrays</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Fruit[] fruit = <span class="keyword">new</span> Apple[<span class="number">10</span>];</div><div class="line"></div><div class="line">        fruit[<span class="number">0</span>] = <span class="keyword">new</span> Apple(); <span class="comment">// 编译期、运行期都 OK</span></div><div class="line">        fruit[<span class="number">1</span>] = <span class="keyword">new</span> Jonathan(); <span class="comment">// 编译期、运行期都 OK</span></div><div class="line">        fruit[<span class="number">3</span>] = <span class="keyword">new</span> Fruit();  <span class="comment">//  编译期 OK、运行期抛出 java.lang.ArrayStoreException(因为 fruit 的运行时类型是 Apple[], 而不是 Fruit[] 或 Orange[]) </span></div><div class="line"></div><div class="line">      	<span class="comment">// 说明 Fruit[] 是 Apple[] 的父类型</span></div><div class="line">     	System.out.println(Fruit[].class.isAssignableFrom(Apple[].class));   <span class="comment">// true </span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由此可以说明：</p>
<ul>
<li><p>由 12 行可知，该行代码编译期正常，则进一步说明：<strong>编译器的类型检查是针对引用的</strong>(Fruit型数组可以放入Fruit及其子类型对象)；但在运行时，由于 <code>fruit引用</code> 实际上指的是一个 <code>Apple数组</code>，而作为 <code>Apple数组</code> 则只可以向其中放入Apple及其子类型对象，因此当放入 Fruit对象时，抛出异常</p>
</li>
<li><p>15 行可知，<code>Fruit[]</code> 是 <code>Apple[]</code> 的父类型，因此根据Java多态特性，前者可以指向后者对象。</p>
<p>​</p>
</li>
</ul>
<p>我们知道，<strong>泛型的主要目标之一就是将这种错误检查移到编译期</strong>，那么，如果我们用泛型容器代替数组，那将会发生什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonCovariantGenerics</span> </span>&#123; </div><div class="line"></div><div class="line">     List&lt;Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();  <span class="comment">// Compile Error: Type Mismatch </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　    由以上代码可以知道，编译期根本不允许我们这么做。试想，如果编译期允许我们这样做，该容器就允许存入任何类型的对象，只要它是一种Fruit，而不像数组那样会抛出运行时异常，违背了泛型的初衷（泛型保证容器的类型安全检查）。所以，在编译期看来<code>List&lt;Fruit&gt;</code>和 <code>List&lt;Apple&gt;</code>根本就是两种不同的类型，并无任何继承关系。 </p>
<p>​</p>
<p>但是，有时你想要在以上两个类型之间建立某种向上转型关系，这就引出了通配符的上界。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndCovariance</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 允许我们向上转型，向数组那样</span></div><div class="line">        List&lt;? extends Fruit&gt; flist = Arrays.asList(<span class="keyword">new</span> Apple());</div><div class="line">        <span class="comment">// Compile Error: can’t add any type of object:</span></div><div class="line">        flist.add(<span class="keyword">new</span> Apple());     <span class="comment">// Compile Error</span></div><div class="line">        flist.add(<span class="keyword">new</span> Fruit());     <span class="comment">// Compile Error</span></div><div class="line">        flist.add(<span class="keyword">new</span> Object());     <span class="comment">// Compile Error</span></div><div class="line">      	flist.add(<span class="keyword">null</span>); <span class="comment">// Legal but uninteresting</span></div><div class="line">        <span class="comment">// We know that it returns at least Fruit:</span></div><div class="line">        Fruit f = flist.get(<span class="number">0</span>);</div><div class="line">        Object o = flist.get(<span class="number">0</span>);</div><div class="line">        Apple a = flist.get(<span class="number">0</span>);   <span class="comment">// Compile Error:Type mismatch</span></div><div class="line"></div><div class="line">        flist.contains(<span class="keyword">new</span> Apple());   <span class="comment">// OK</span></div><div class="line">        flist.indexOf(<span class="keyword">new</span> Apple());    <span class="comment">// OK</span></div><div class="line"></div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>​    对于上述例子，flist 的类型就是<code>List&lt;? extends Fruit&gt;</code>了，但这并不意味着可以向这个 List 可以添加任何类型的 Fruit，甚至于不能添加 Apple。虽然编译器知道这个 List 持有的是 Fruit，但并不知道其具体持有哪种特定类型(可能是<code>List&lt;Fruit&gt;</code>，<code>List&lt;Apple&gt;</code>，<code>List&lt;Orange&gt;</code>，<code>List&lt;Jonathan&gt;</code>)，所以编译器不知道该添加那种类型的对象才能保证类型安全（add 方法的参数为 <code>? extends Fruit</code> ），因而编译器杜绝任何添加任何类型的 Fruit。但是，对于诸如<code>get(int index)</code>【我们进行读取操作时，编译器是允许的，而且编译器还知道 List 中的任何一个对象至少具有 Fruit类型】、<code>contains(Object o)</code>和 <code>indexof(Object o)</code>等操作，由于其参数类型不涉及通配符，因此编译器允许调用这些操作。</p>
<p>​    <strong>因此，一旦执行这种向上转型，我们就丢掉向其中添加任何对象的能力。更一般地，编译器会直接拒绝对参数列表中涉及通配符的方法的调用。因此，这意味着将由泛型类的设计者来决定哪些调用地安全的，并使用 Object类型 作为其参数类型，例如 contains 方法和 indexof 方法</strong>。例如,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> T value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(T val)</span> </span>&#123;</div><div class="line">        value = val;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T val)</span> </span>&#123;</div><div class="line">        value = val;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.equals(obj);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Holder&lt;Apple&gt; Apple = <span class="keyword">new</span> Holder&lt;Apple&gt;(<span class="keyword">new</span> Apple());</div><div class="line">        Apple d = Apple.get();</div><div class="line">        Apple.set(d);</div><div class="line">        Holder&lt;? extends Fruit&gt; fruit = Apple; <span class="comment">// OK</span></div><div class="line">        Fruit p = fruit.get();</div><div class="line">        d = (Apple) fruit.get(); <span class="comment">// Returns ‘Fruit’，类型擦除，返回上界</span></div><div class="line"></div><div class="line">       <span class="comment">// No warning,运行时异常 java.lang.ClassCastException</span></div><div class="line">        Orange c = (Orange) fruit.get(); </div><div class="line">       <span class="comment">// fruit.set(new Apple()); // Cannot call set()，参数列表含通配符</span></div><div class="line">       <span class="comment">// fruit.set(new Fruit()); // Cannot call set()，参数列表含通配符</span></div><div class="line"></div><div class="line">       fruit.equals(d); <span class="comment">// OK，参数列表不含通配符</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>超类型通配符 / 通配符的下界 / 逆变</p>
<p>​    我们可以使用<code>超类型通配符</code>指定通配符的下界, 方法是<code>&lt;? super MyClass&gt;</code>,甚至可以用在类型参数上<code>&lt;? super MyClass&gt;</code>(尽管我们不能对泛型参数给出一个超类型边界；即不能声明<code>&lt;T super MyClass&gt;</code>)。这使得我们可以安全的传递一个对象到泛型类型中，因此，有了超类型通配符，就可以向 Collection 写入了,如下图所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTypeWildCards</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(List&lt;? <span class="keyword">super</span> Apple&gt; apples)</span></span>&#123;</div><div class="line">    apples.add(<span class="keyword">new</span> Apple());</div><div class="line">    apples.add(<span class="keyword">new</span> Jonathan());</div><div class="line">    apples.add(<span class="keyword">new</span> Fruit()); <span class="comment">//error</span></div><div class="line">    </div><div class="line">    apples.add(<span class="keyword">new</span> Apple());</div><div class="line">    apples.addAll(Collection&lt;? extends Apple&gt;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    　由图片可知，<strong>参数 apples 是 Apple 或 Apple的某种基类型 (例如：Fruit，Object，…) 的 List</strong>，也就是说，该 List 可以是 <code>List&lt;Apple&gt;</code>, <code>List&lt;Fruit&gt;</code> 或<code>List&lt;Object&gt;</code>等，但无论具体指的是哪一种，我们向其中添加 Apple 或 Apple的子类型 总是安全的。但编译器不允许向该 List 放入一个 Fruit 对象， 因为 该List 的类型可能是 <code>List&lt;Apple&gt;</code>, 这样将会违背泛型的本意。</p>
<p>​    对于<code>List&lt;? super Apple&gt;</code>,在读取容器元素时，由于该容器所包含的元素可能是 Object类型、 Fruit类型 和 Apple类型，因此，从容器所读取到的元素只能确定是 Object类型的，如下面图片所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWriting</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeExact</span><span class="params">(List&lt;T&gt; list, T item)</span> </span>&#123;</div><div class="line">		list.add(item);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> List&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</div><div class="line">	<span class="keyword">static</span> List&lt;Fruit&gt; fruit = <span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</div><div class="line">		writeExact(apples,<span class="keyword">new</span> Apple());</div><div class="line">		writeExact(fruit,<span class="keyword">new</span> Apple());</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeWithWildcard</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; list, T item)</span> </span>&#123;</div><div class="line">		list.add(item);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</div><div class="line">		writeWithWildcard(apples, <span class="keyword">new</span> Apple());</div><div class="line">		writeWithWildcard(fruit, <span class="keyword">new</span> Apple());</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		f1();</div><div class="line">		f2();</div><div class="line">		</div><div class="line">		System.out.println(fruit.size());</div><div class="line">		System.out.println(apples.size());</div><div class="line">		</div><div class="line">		List&lt;? <span class="keyword">super</span> Apple&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();;</div><div class="line">		list.add(<span class="keyword">new</span> Apple());</div><div class="line">		list.add(<span class="keyword">new</span> HongFushi());</div><div class="line">		</div><div class="line">		Object object = list.get(<span class="number">0</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>协变与逆变</p>
<p>  逆变与协变用来描述类型转换（type transformation）后的继承关系，其定义：如果 A,B 表示类型，f(⋅)表示类型转换，≤ 表示继承关系（比如，A ≤ B 表示A是B的子类);</p>
<ul>
<li>f(⋅) 是逆变（contravariant）的，当 A≤B 时有 f(B)≤f(A) 成立；</li>
<li>f(⋅) 是协变（covariant）的，当 A≤B 时有 f(A)≤f(B) 成立；</li>
<li><p>f(⋅) 是不变（invariant）的，当 A≤B 时上述两个式子均不成立，即f(A)与f(B)相互之间没有继承关系</p>
<p>接下来，我们看看Java中的常见类型转换的协变性、逆变性或不变性:</p>
</li>
<li><p>泛型</p>
<p>​    令f(A) = <code>ArrayList&lt;A&gt;</code>，那么f(⋅) 是逆变、协变还是不变的呢？如果是逆变，则<code>ArrayList&lt;Integer&gt;</code>是<code>ArrayList&lt;Number&gt;</code>的父类型；如果是协变，则<code>ArrayList&lt;Integer&gt;</code>是<code>ArrayList&lt;Number&gt;</code>的子类型；如果是不变，二者没有相互继承关系。由于实际上<code>ArrayList&lt;Number&gt;</code>和<code>ArrayList&lt;Integer&gt;</code>无关，所以<strong>泛型是不变</strong>的。</p>
</li>
<li><p>数组</p>
<p>令f(A) = A[]，容易证明数组是协变的;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Number[] numbers = <span class="keyword">new</span> Integer[<span class="number">3</span>];</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>协变与逆变的实现</p>
<p>我们知道<strong>Java 中的泛型是不变的</strong>，可我们有时需要实现泛型的逆变与协变，怎么办呢？ 这时，通配符 ? 派上了用场：</p>
<ul>
<li><p><strong>&lt;? extends&gt;</strong>实现了<strong>泛型的协变</strong>，</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;? extends Apple&gt; l3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">ArrayList&lt;? extends Fruit&gt; l4 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">l4 = l3;</div></pre></td></tr></table></figure>
<p>​    对于 <code>ArrayList&lt;? extends Apple&gt; 类型</code>，我们知道其表示某种具体类型(只是没有确定下来)，但是无论其具体指的是<code>ArrayList&lt;Apple&gt; 类型</code>还是<code>ArrayList&lt;Jonathan&gt; 类型</code>,都是可以赋给<code>ArrayList&lt;? extends Fruit&gt; 类型</code>的引用的，反之则不可以。因此，我们可以认为<code>ArrayList&lt;? extends Fruit&gt; 类型</code>是<code>ArrayList&lt;? extends Apple&gt; 类型</code>的父类型，故<strong><code>&lt;? extends&gt;</code></strong>实现了泛型的协变。 </p>
</li>
<li><p><strong>&lt;? super&gt;</strong>实现了<strong>泛型的逆变</strong>，</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;? <span class="keyword">super</span> Apple&gt; l1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">ArrayList&lt;? <span class="keyword">super</span> Fruit&gt; l2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">l1 = l2;</div></pre></td></tr></table></figure>
<p>​    对于 <code>ArrayList&lt;? super Fruit&gt; 类型</code>,我们知道其表示某种具体类型(只是没有确定下来)，但是无论其具体指的是<code>ArrayList&lt;Fruit&gt; 类型</code>还是<code>ArrayList&lt;Object&gt; 类型</code>,都是可以赋给<code>ArrayList&lt;? super Apple&gt; 类型</code>的引用的，反之则不可以。因此，我们可以认为<code>ArrayList&lt;? super Apple&gt; 类型</code>是<code>ArrayList&lt;? super Fruit&gt; 类型</code>的父类型，故 <strong><code>&lt;? super&gt;</code></strong>实现了泛型的逆变。</p>
<p>​</p>
</li>
</ul>
</li>
<li><p><strong>PECS 准则 (producer-extends, consumer-super)</strong></p>
<p>​    <em>我们知道 &lt;?&gt; 表示：我想使用 Java泛型 来编写代码，而不是用原生类型；但是在当前这种情况下，我并不能确定下泛型参数的具体类型，因此用<strong><code>?</code></strong>表示任何某种类型<em>*。因此，根据我们对通配符的了解，使用无界通配符的泛型类不能够写数据，而在读取数据时，所赋值的引用也只能是 Object 类型。那么，我们究竟如何向泛型类写入、读取数据呢？</em></em></p>
<p>​    <strong>《Effective Java2》给出了答案：</strong> PECS  :  producer(读取)-extends, consumer(写入)-super。换句话说，如果输入参数表示一个 T 的生产者，就使用&lt;? extends T&gt;；如果输入参数表示一个 T 的消费者，就使用&lt;? super T&gt;。总之，通配符类型可以保证方法能够接受它们应该接受的参数，并拒绝那些应该拒绝的参数。** 比如，一个简单的 Stack API ：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">Stack</span>&lt;<span class="title">E</span>&gt;</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在要实现 <code>pushAll(Iterable&lt;E&gt; src)</code> 方法，将实现 Iterable 接口的 src 的元素逐一入栈：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterable&lt;E&gt; src)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(E e : src)</div><div class="line">        push(e)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　那么问题就来了：假设有一个实例化 <code>Stack&lt;Number&gt;</code> 的对象 <strong>stack(类型参数被实例化为Number)</strong>，显然， 我们向这个 stack 中加入 <code>Integer型</code>或<code>Float型</code>元素都是可以的，因为这些元素本来就是<code>Number型</code>的。因此， src 就包括但不限于 <code>Iterable&lt;Integer&gt;</code> 与 <code>Iterable&lt;Float&gt;</code> 两种可能；这时，在调用上述 <code>pushAll方法</code> 时，编译器就会产生 <code>type mismatch</code> 错误。原因是显而易见的，因为Java中泛型是不变的，<code>Iterable&lt;Integer&gt;</code> 与  <code>Iterable&lt;Float&gt;</code> 都不是 <code>Iterable&lt;Number&gt;</code>及其子类型中的一种。所以，我们对 <code>pushAll方法</code> 的设计就存在逻辑上的问题。因此，应改为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Wildcard type for parameter that serves as an E producer</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterable&lt;? extends E&gt; src)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (E e : src)</div><div class="line">        push(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，我们就可以实现将 <code>实现Iterable接口</code> 的 <code>E类型的容器</code>中的元素读取到我们的 Stack 中。</p>
<hr>
<p>那么，如果现在要实现 <code>popAll(Collection&lt;E&gt; dst)方法</code>，将 Stack 中的元素依次取出并添加到 dst 中，如果不用通配符实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// popAll method without wildcard type - deficient!</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;E&gt; dst)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (!isEmpty())</div><div class="line">        dst.add(pop());   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    同样地，假设有一个实例化 <code>Stack&lt;Number&gt;</code> 的对象 stack ， dst 为 <code>Collection&lt;Object&gt;</code>，显然，这是合理的。但如果我们调用上述的 <code>popAll(Collection&lt;E&gt; dst)方法</code>，编译器会报出 <code>type mismatch</code> 错误，编译器不允许我们进行这样的操作。原因是显而易见的，因为 <code>Collection&lt;Object&gt;</code> 不是 <code>Collection&lt;Number&gt;</code>及其子类型的一种。所以，我们对 <code>popAll方法</code> 的设计就存在逻辑上的问题。因此，应改为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Wildcard type for parameter that serves as an E consumer</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; dst)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (!isEmpty())</div><div class="line">        dst.add(pop());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>这样，我们就可以实现将 `Stack&lt;E&gt;` 中的 元素读取到我们的 Collection 中 。
</code></pre><p>​    在上述例子中，<strong>在调用 pushAll方法时 src生产了 E实例（produces E instances），在调用 popAll方法时 dst消费了 E实例（consumes E instances）</strong>。Naftalin与Wadler 将 PECS 称为 <strong>Get and Put Principle</strong>。</p>
<p>​    此外，我们再来学习一个例子： java.util.Collections 的 copy 方法(JDK1.7)，它的目的是将所有元素从一个列表(src)复制到另一个列表(dest)中。显然，在这里，src 是生产者，它负责产生 T类型的实例；dest 是消费者，它负责消费 T类型的实例。这完美地诠释了 PECS ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// List&lt;? extends T&gt; 类型的 src 囊括了所有 T类型及其子类型 的列表  </span></div><div class="line"><span class="comment">// List&lt;? super T&gt; 类型的 dest 囊括了所有可以将 src中的元素添加进去的 List种类 </span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</div><div class="line">    <span class="comment">// 将 src 复制到 dest 中</span></div><div class="line">    <span class="keyword">int</span> srcSize = src.size();</div><div class="line">    <span class="keyword">if</span> (srcSize &gt; dest.size())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Source does not fit in dest"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (srcSize &lt; COPY_THRESHOLD ||</div><div class="line">        (src <span class="keyword">instanceof</span> RandomAccess &amp;&amp; dest <span class="keyword">instanceof</span> RandomAccess)) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;srcSize; i++)</div><div class="line">            dest.set(i, src.get(i));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ListIterator&lt;? <span class="keyword">super</span> T&gt; di=dest.listIterator();</div><div class="line">        ListIterator&lt;? extends T&gt; si=src.listIterator();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;srcSize; i++) &#123;</div><div class="line">            di.next();</div><div class="line">            di.set(si.next());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>故有PECS总结：</strong></p>
<ul>
<li>输入参数是生产者时，用 ? extends T ；</li>
<li>输入参数是消费者时，用 ? super T ；</li>
<li>输入参数既是生产者又是消费者时，那么通配符类型没什么用了：因为你需要的是严格类型匹配，这是不用任何通配符而得到的；</li>
<li>无界通配符<code>&lt;?&gt;</code> 既不能做生产者(读出来的是Object),又不能做消费者(写不进去)；</li>
</ul>
</li>
</ol>
<h2 id="编译器如何处理泛型"><a href="#编译器如何处理泛型" class="headerlink" title="编译器如何处理泛型"></a>编译器如何处理泛型</h2><p>通常情况下，一个编译器处理泛型有两种方式：</p>
<ol>
<li><p><strong>Code Specializatio</strong></p>
<p>在实例化一个泛型类或泛型方法时都产生一份新的目标代码（字节码or二进制代码）。例如，针对一个泛型list，可能需要针对string，integer，float产生三份目标代码。</p>
</li>
<li><p><strong>Code Sharing</strong></p>
<p>对每个泛型类只生成唯一的一份目标代码；该泛型类的所有实例都映射到这份目标代码上，在需要的时候执行类型检查和类型转换。</p>
<ul>
<li>C++中的模板（template）是典型的Code specialization实现<br>C++编译器会为每一个泛型类实例生成一份执行代码。执行代码中integer list和string<br>list是两种不同的类型。这样会导致代码膨胀（code bloat），不过有经验的C＋＋程序员可以有技巧的避免代码膨胀。<br>另外，在引用类型系统中，这种方式会造成空间的浪费。因为引用类型集合中元素本质上都是一个指针。没必要为每个类型都产生一份执行代码。而这也是Java编译器中采用Code<br> sharing方式处理泛型的主要原因。</li>
<li>Java 是典型的Code sharing实现<br>Java编译器通过Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。</li>
</ul>
<p>​</p>
</li>
</ol>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><ol>
<li>要点<ul>
<li><strong>类型擦除</strong>: <strong>通过移除泛型类定义的类型参数并将定义中每个类型变量替换成对应类型参数的非泛型上界(第一个边界)，得到原生类型(raw type)</strong></li>
<li>类型擦除是 Java 泛型实现的一种折中，以便在不破坏现有类库的情况下，将泛型融入Java，并且保证兼容性。（泛型出现前后的Java类库互相兼容）</li>
<li>类型擦除指的是通过类型参数合并，将泛型类型实例关联到同一份字节码(Class 对象)上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。类型擦除的<code>关键</code>在于从泛型类型中清除类型参数的相关信息，并且在必要的时候添加类型检查和类型转换的方法。</li>
<li>擦除是在<code>编译期</code>完成的。类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。泛型类型只有在<code>静态类型检查期间</code>才会出现，在此之后，程序中的所有泛型类型都将被擦除，并替换为它们的<code>非泛型上界</code>。因此，<code>在泛型代码内部，无法获得任何有关泛型参数类型的信息。</code></li>
</ul>
</li>
</ol>
<ol>
<li>编译器是如何配合类型擦除的？</li>
</ol>
<p><img src="http://img.blog.csdn.net/20160902231313388" alt="编译器擦除"></p>
<ol>
<li><p>类型擦除的主要过程</p>
<p><strong>对于Pair&lt;&gt;</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//代码示例 A</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </div><div class="line">    <span class="keyword">private</span> T value;  </div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> value;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T  value)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.value = value;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Pair&lt;&gt;的原始类型为：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//代码示例 B</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Object value;  </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> value;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object  value)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.value = value;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>以下是类型擦除示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//代码示例 1</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span> &lt;<span class="title">A</span>&gt; </span>&#123; </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">( A that)</span></span>; </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">//类型擦除后</span></div><div class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span> </span>&#123; </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">( Object that)</span></span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//代码示例 2</span></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NumericValue</span> <span class="keyword">implements</span> <span class="title">Comparable</span> &lt;<span class="title">NumericValue</span>&gt; </span>&#123; </div><div class="line">  priva <span class="keyword">byte</span> value;  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NumericValue</span> <span class="params">(<span class="keyword">byte</span> value)</span> </span>&#123; <span class="keyword">this</span>.value = value; &#125;  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">( NumericValue that)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.value - that.value; &#125; </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">//类型擦除后</span></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NumericValue</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Comparable</span></span>&#123;</div><div class="line">    <span class="comment">//域</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> value;</div><div class="line">    <span class="comment">//构造器</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumericValue</span><span class="params">(<span class="keyword">byte</span>)</span></span>;</div><div class="line">    <span class="comment">//方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(NumericValue)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(java.lang.Object)</span></span>; <span class="comment">//桥方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getValue</span><span class="params">( )</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//代码示例 3</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span>&#123;  </div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;A extends Comparable&lt;A&gt;&gt; <span class="function">A <span class="title">max</span><span class="params">(Collection &lt;A&gt; xs)</span> </span>&#123; </div><div class="line">    Iterator&lt;A&gt; xi = xs.iterator(); </div><div class="line">    A w = xi.next(); </div><div class="line">    <span class="keyword">while</span>(xi.hasNext()) &#123; </div><div class="line">      A x = xi.next(); </div><div class="line">      <span class="keyword">if</span>(w.compareTo(x) &lt; <span class="number">0</span>) </div><div class="line">         w = x; </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> w; </div><div class="line">  &#125; </div><div class="line">&#125; </div><div class="line"><span class="comment">//类型擦除后</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span>&#123;  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">max</span><span class="params">(Collection xs)</span> </span>&#123; </div><div class="line">    Iterator xi = xs.iterator(); </div><div class="line">    Comparable w = (Comparable) xi.next(); </div><div class="line">    <span class="keyword">while</span> (xi.hasNext()) &#123; </div><div class="line">      Comparable x = (Comparable) xi.next(); </div><div class="line">      <span class="keyword">if</span> (w.compareTo(x) &lt; <span class="number">0</span>) w = x; </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> w; </div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//代码示例 4</span></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123; </div><div class="line">    LinkedList&lt;NumericValue&gt; numberList = <span class="keyword">new</span> LinkedList&lt;NumericValue&gt; (); </div><div class="line">    numberList.add(<span class="keyword">new</span> NumericValue((<span class="keyword">byte</span>)<span class="number">0</span>));  </div><div class="line">    numberList.add(<span class="keyword">new</span> NumericValue((<span class="keyword">byte</span>)<span class="number">1</span>));  </div><div class="line">    NumericValue y = Collections.max( numberList );  </div><div class="line">  &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//类型擦除后</span></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[ ] args)</span> </span>&#123; </div><div class="line">    LinkedList numberList = <span class="keyword">new</span> LinkedList(); </div><div class="line">    numberList.add(<span class="keyword">new</span> NumericValue((<span class="keyword">byte</span>)<span class="number">0</span>));  ，</div><div class="line">    numberList.add(<span class="keyword">new</span> NumericValue((<span class="keyword">byte</span>)<span class="number">1</span>));  </div><div class="line">    NumericValue y = (NumericValue) Collections.max( numberList );  </div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　第一个泛型类被擦除后, A被替换为最左边界 Object。由于Comparable是一个泛型接口，所以Comparable的类型参数NumericValue被擦除掉并将相关参数置换为 Object，但是这直接导致 NumericValue 没有实现接口（重写）Comparable的compareTo(Object that)方法，于是编译器充当好人，添加了一个<code>桥方法（由编译器在编译时自动添加）</code>。</p>
<p>　　第二个示例中限定了类型参数的边界，A必须为Comparable的子类，按照类型擦除的过程，先将所有的类型参数替换为最左边界Comparable，得到最终的擦除后结果。</p>
</li>
</ol>
<h2 id="泛型带来的问题及解决方法"><a href="#泛型带来的问题及解决方法" class="headerlink" title="泛型带来的问题及解决方法"></a>泛型带来的问题及解决方法</h2><ol>
<li><p><strong>以参数化类型与原始类型的兼容性说明引用是类型检查所针对的对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test10</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line"></div><div class="line">        ArrayList&lt;String&gt; arrayList1=<span class="keyword">new</span> ArrayList();  </div><div class="line">        arrayList1.add(<span class="string">"1"</span>);  <span class="comment">//编译通过  </span></div><div class="line">        arrayList1.add(<span class="number">1</span>);  <span class="comment">//编译错误  </span></div><div class="line">        String str1=arrayList1.get(<span class="number">0</span>);  <span class="comment">//返回类型就是 String  </span></div><div class="line"></div><div class="line">        ArrayList arrayList2=<span class="keyword">new</span> ArrayList&lt;String&gt;();  </div><div class="line">        arrayList2.add(<span class="string">"1"</span>);  <span class="comment">//编译通过  </span></div><div class="line">        arrayList2.add(<span class="number">1</span>);  <span class="comment">//编译通过  </span></div><div class="line">        Object object=arrayList2.get(<span class="number">0</span>);  <span class="comment">//返回类型就是 Object  </span></div><div class="line"></div><div class="line">        <span class="keyword">new</span> ArrayList&lt;String&gt;().add(<span class="string">"11"</span>);  <span class="comment">//编译通过  </span></div><div class="line">        <span class="keyword">new</span> ArrayList&lt;String&gt;().add(<span class="number">22</span>);  <span class="comment">//编译错误  </span></div><div class="line">        String string=<span class="keyword">new</span> ArrayList&lt;String&gt;().get(<span class="number">0</span>);  <span class="comment">//返回类型就是 String  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    因此我们可以得出结论：<strong>类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。</strong></p>
<p>​</p>
</li>
<li><p><strong>所有动作都发生在边界处（对传递进来的值，编译器进行额外的检查；对真正传递出去的值，编译器自动插入的转型）</strong></p>
<p>​    因为类型擦除的问题，所以所有的泛型类型最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 代码片段1</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHolder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Object obj;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.obj = obj;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObj</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SimpleHolder holder = <span class="keyword">new</span> SimpleHolder();</div><div class="line">        holder.setObj(<span class="string">"Item"</span>);</div><div class="line">        String s = (String)holder.getObj();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>反编译这个类，得到下面代码片段：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public void setObj(java.lang.Object);</div><div class="line">  Code:</div><div class="line">   0:   aload_0</div><div class="line">   1:   aload_1</div><div class="line">   2:   putfield        #2; //Field obj:Ljava/lang/Object;</div><div class="line">   5:   return</div><div class="line"></div><div class="line">public java.lang.Object getObj();</div><div class="line">  Code:</div><div class="line">   0:   aload_0</div><div class="line">   1:   getfield        #2; //Field obj:Ljava/lang/Object;</div><div class="line">   4:   areturn</div><div class="line"></div><div class="line">public static void main(java.lang.String[]);</div><div class="line">  Code:</div><div class="line">   0:   new     #3; //class SimpleHolder</div><div class="line">   3:   dup</div><div class="line">   4:   invokespecial   #4; //Method "&lt;init&gt;":()V</div><div class="line">   7:   astore_1</div><div class="line">   8:   aload_1</div><div class="line">   9:   ldc     #5; //String Item</div><div class="line">   11:  invokevirtual   #6; //Method setObj:(Ljava/lang/Object;)V</div><div class="line">   14:  aload_1</div><div class="line">   15:  invokevirtual   #7; //Method getObj:()Ljava/lang/Object;</div><div class="line">   18:  checkcast       #8; //class java/lang/String</div><div class="line">   21:  astore_2</div><div class="line">   22:  return</div></pre></td></tr></table></figure>
<p>现将泛型应用到上述代码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 代码片段 2</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> T obj;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.obj = obj;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getObj</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        GenericHolder&lt;String&gt; holder = <span class="keyword">new</span> GenericHolder&lt;String&gt;();</div><div class="line">        holder.setObj(<span class="string">"Item"</span>);</div><div class="line">        String s = holder.getObj();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>反编译这个类，得到下面代码片段：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public void setObj(java.lang.Object);</div><div class="line">  Code:</div><div class="line">   0:   aload_0</div><div class="line">   1:   aload_1</div><div class="line">   2:   putfield        #2; //Field obj:Ljava/lang/Object;</div><div class="line">   5:   return</div><div class="line"></div><div class="line">public java.lang.Object getObj();</div><div class="line">  Code:</div><div class="line">   0:   aload_0</div><div class="line">   1:   getfield        #2; //Field obj:Ljava/lang/Object;</div><div class="line">   4:   areturn</div><div class="line"></div><div class="line">public static void main(java.lang.String[]);</div><div class="line">  Code:</div><div class="line">   0:   new     #3; //class GenericHolder</div><div class="line">   3:   dup</div><div class="line">   4:   invokespecial   #4; //Method "&lt;init&gt;":()V</div><div class="line">   7:   astore_1</div><div class="line">   8:   aload_1</div><div class="line">   9:   ldc     #5; //String Item</div><div class="line">   11:  invokevirtual   #6; //Method setObj:(Ljava/lang/Object;)V</div><div class="line">   14:  aload_1</div><div class="line">   15:  invokevirtual   #7; //Method getObj:()Ljava/lang/Object;</div><div class="line">   18:  checkcast       #8; //class java/lang/String</div><div class="line">   21:  astore_2</div><div class="line">   22:  return</div></pre></td></tr></table></figure>
<p>在上述应用泛型的代码中，将 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String s = holder.getObj();</div></pre></td></tr></table></figure>
<p>替换为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">holder.getObj();</div></pre></td></tr></table></figure>
<p>反编译后，有代码片段：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public void setObj(java.lang.Object);</div><div class="line">  Code:</div><div class="line">   0:   aload_0</div><div class="line">   1:   aload_1</div><div class="line">   2:   putfield        #2; //Field obj:Ljava/lang/Object;</div><div class="line">   5:   return</div><div class="line"></div><div class="line">public java.lang.Object getObj();</div><div class="line">  Code:</div><div class="line">   0:   aload_0</div><div class="line">   1:   getfield        #2; //Field obj:Ljava/lang/Object;</div><div class="line">   4:   areturn</div><div class="line"></div><div class="line">public static void main(java.lang.String[]);</div><div class="line">  Code:</div><div class="line">   0:   new     #3; //class GenericHolder</div><div class="line">   3:   dup</div><div class="line">   4:   invokespecial   #4; //Method "&lt;init&gt;":()V</div><div class="line">   7:   astore_1</div><div class="line">   8:   aload_1</div><div class="line">   9:   ldc     #5; //String Item</div><div class="line">   11:  invokevirtual   #6; //Method setObj:(Ljava/lang/Object;)V</div><div class="line">   14:  aload_1</div><div class="line">   15:  invokevirtual   #7; //Method getObj:()Ljava/lang/Object;</div><div class="line">   18:  pop</div><div class="line">   19:  return</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>首先，代码片段 1 和代码片段 2 二者所产生的字节码是相同的。看第15，它调用的是getObj()方法，返回值是Object，说明类型擦除了。然后第18，它做了一个checkcast操作，即检查类型#8， 在上面找#8引用的类型，它是一个String类型，即作String类型的强转。所以不是在get方法里强转的，是<strong>在你调用的地方强转</strong>的。对进入setObj()的类型进行检查是不需要的，因为这将由编译器执行。而对从getObj()返回的值进行转型仍旧是需要的，但这与你自己必须执行的操作是一样的–此处它将由编译器自动插入。也就是说，在泛型中，<code>所有动作都发生在边界处</code> – <strong>对传递进来的值进行额外的编译器检查，并由编译器自动插入对传递出去的值的转型</strong>。</li>
<li>其次，在未将 getObj() 的值赋给String时，由代码片段可知，<strong>编译器并未自动插入转型代码，可见所谓编译器自动插入对传递出去的值的转型的前提条件</strong>是：<strong>其必须是真正传递出去，即必须赋值给引用.</strong>(当然，虽然 getObj() 的返回值的类型是 Object， 但是其实质上是一个 String， 因此直接进行操作 “ getObj() instanceof String ”时，返回值也是 true.)</li>
</ul>
<p>再看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> T[] array;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArray</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123;</div><div class="line">        array = (T[]) <span class="keyword">new</span> Object[sz];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</div><div class="line">        array[index] = item;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> array[index];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> T[] rep() &#123; <span class="keyword">return</span> array; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        GenericArray&lt;Integer&gt; gai = <span class="keyword">new</span> GenericArray&lt;Integer&gt;(<span class="number">10</span>);</div><div class="line">        gai.put(<span class="number">0</span>, <span class="keyword">new</span> Integer(<span class="number">4</span>));</div><div class="line"></div><div class="line">        gai.get(<span class="number">0</span>);</div><div class="line">        Integer i = gai.get(<span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">// This causes a ClassCastException:</span></div><div class="line">          Integer[] ia = gai.rep();</div><div class="line"></div><div class="line">        <span class="comment">// This is OK:</span></div><div class="line">        Object[] oa = (Object[])gai.rep();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>反编译可得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">public class GenericArray extends java.lang.Object&#123;</div><div class="line">public GenericArray(int);</div><div class="line">  Code:</div><div class="line">   0:   aload_0</div><div class="line">   1:   invokespecial   #1; //Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</div><div class="line">   4:   aload_0</div><div class="line">   5:   iload_1</div><div class="line">   6:   anewarray       #2; //class java/lang/Object</div><div class="line">   9:   checkcast       #3; //class &quot;[Ljava/lang/Object;&quot;</div><div class="line">   12:  putfield        #4; //Field array:[Ljava/lang/Object;</div><div class="line">   15:  return</div><div class="line"></div><div class="line">public void put(int, java.lang.Object);</div><div class="line">  Code:</div><div class="line">   0:   aload_0</div><div class="line">   1:   getfield        #4; //Field array:[Ljava/lang/Object;</div><div class="line">   4:   iload_1</div><div class="line">   5:   aload_2</div><div class="line">   6:   aastore</div><div class="line">   7:   return</div><div class="line"></div><div class="line">public java.lang.Object get(int);</div><div class="line">  Code:</div><div class="line">   0:   aload_0</div><div class="line">   1:   getfield        #4; //Field array:[Ljava/lang/Object;</div><div class="line">   4:   iload_1</div><div class="line">   5:   aaload</div><div class="line">   6:   areturn</div><div class="line"></div><div class="line">public java.lang.Object[] rep();</div><div class="line">  Code:</div><div class="line">   0:   aload_0</div><div class="line">   1:   getfield        #4; //Field array:[Ljava/lang/Object;</div><div class="line">   4:   areturn</div><div class="line"></div><div class="line">public static void main(java.lang.String[]);</div><div class="line">  Code:</div><div class="line">   0:   new     #5; //class GenericArray</div><div class="line">   3:   dup</div><div class="line">   4:   bipush  10</div><div class="line">   6:   invokespecial   #6; //Method &quot;&lt;init&gt;&quot;:(I)V</div><div class="line">   9:   astore_1</div><div class="line">   10:  aload_1</div><div class="line">   11:  iconst_0</div><div class="line">   12:  new     #7; //class java/lang/Integer</div><div class="line">   15:  dup</div><div class="line">   16:  iconst_4</div><div class="line">   17:  invokespecial   #8; //Method java/lang/Integer.&quot;&lt;init&gt;&quot;:(I)V</div><div class="line">   20:  invokevirtual   #9; //Method put:(ILjava/lang/Object;)V</div><div class="line">   23:  aload_1</div><div class="line">   24:  iconst_0</div><div class="line">   25:  invokevirtual   #10; //Method get:(I)Ljava/lang/Object;</div><div class="line">   28:  pop</div><div class="line">   29:  aload_1</div><div class="line">   30:  iconst_0</div><div class="line">   31:  invokevirtual   #10; //Method get:(I)Ljava/lang/Object;</div><div class="line">   34:  checkcast       #7; //class java/lang/Integer</div><div class="line">   37:  astore_2</div><div class="line">   38:  aload_1</div><div class="line">   39:  invokevirtual   #11; //Method rep:()[Ljava/lang/Object;</div><div class="line">   42:  checkcast       #12; //class &quot;[Ljava/lang/Integer;&quot;</div><div class="line">   45:  astore_3</div><div class="line">   46:  aload_1</div><div class="line">   47:  invokevirtual   #11; //Method rep:()[Ljava/lang/Object;</div><div class="line">   50:  checkcast       #3; //class &quot;[Ljava/lang/Object;&quot;</div><div class="line">   53:  astore  4</div><div class="line">   55:  return</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    结合上面的结论，仔细观察反编译后代码中 <strong>checkcast</strong> 都用在什么地方，加深对<strong>边界就是发生动作的地方</strong>和<strong>自动转型发生在调用处(需要检验两种类型时)</strong>的理解.</p>
<ul>
<li>25显示调用后，直接pop，而31显示在调用处，还要进行 checkcast 操作；</li>
<li>由于类型擦除，操作39之后，进行 checkcast 操作，强转为 Ljava.lang.Integer ，但是由代码<code>array = (T[]) new Object[sz];</code>可知，其 new 的是 Object 数组，是不可能成功强转到 Integer 数组的，就像 Object 对象不能成功强转到 Integer 对象一样，会在运行时抛出 ClassCastException 异常；</li>
<li><p>由于类型擦除，操作47之后，进行 checkcast 操作，由于 rep() 返回的即为 Object 数组，而其要赋给的引用也是 Object[] ,因此不会抛出任何异常。</p>
<p>​</p>
</li>
</ul>
</li>
<li><p>类型擦除与多态的冲突及其解决办法</p>
<p>先看两段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一段代码</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> T first;</div><div class="line">    <span class="keyword">private</span> T second;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.first = first;</div><div class="line">        <span class="keyword">this</span>.second = second;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.first = first;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> first;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T second)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.second = second;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> second;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第二段代码</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Date</span>&gt; </span>&#123;     <span class="comment">// 时间间隔类</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DateInterval</span><span class="params">(Date first, Date second)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(first, second);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Date second)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.setSecond(second);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getSecond</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getSecond();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        DateInterval interval = <span class="keyword">new</span> DateInterval(<span class="keyword">new</span> Date(), <span class="keyword">new</span> Date());</div><div class="line">        Pair&lt;Date&gt; pair = interval; <span class="comment">//超类，多态</span></div><div class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">        System.out.println(<span class="string">"原来的日期："</span>+pair.getSecond());</div><div class="line">        System.out.println(<span class="string">"set进新日期："</span>+date);</div><div class="line">        pair.setSecond(date);</div><div class="line">        System.out.println(<span class="string">"执行pair.setSecond(date)后的日期："</span>+pair.getSecond());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原本子类重写父类的方法，无可非议。但是泛型类的类型擦除造成了一个问题，Pair的<code>原始类型</code>中存在方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span>;</div></pre></td></tr></table></figure>
<p>DateInterval中的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Date second)</span> </span>;</div></pre></td></tr></table></figure>
<p>　我们的本意是想重写父类Pair中的setSecond方法，但是从方法签名上看，这完全是两个不同的方法，<code>类型擦除与多态产生了冲突</code>。而实际情况呢？运行DateInterval的main方法，我们看到<code>public void setSecond(Date second)</code>的确重写了<code>public void setSecond(Object second)</code>方法。这是如何做到的呢？</p>
<p>使用<a href="">Java类分析器</a>对其进行分析，结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span></span>&#123;</div><div class="line">    <span class="comment">//构造器</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DateInterval</span><span class="params">(java.util.Date, java.util.Date)</span></span>;</div><div class="line">    <span class="comment">//方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(java.util.Date)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(java.lang.Object)</span></span>; <span class="comment">//方法 1</span></div><div class="line">    <span class="keyword">public</span> java.util.<span class="function">Date <span class="title">getSecond</span><span class="params">( )</span></span>; <span class="comment">//方法 2</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> java.lang.<span class="function">Object <span class="title">getSecond</span><span class="params">( )</span></span>; <span class="comment">//方法 3，它难道不会和方法 2 冲突？</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　方法1和方法3是我们在源码中不曾定义的，它肯定是由编译器生成的。这个方法称为 <strong>桥方法(bridge method)</strong>，真正覆写超类方法的是它。语句<code>pair.setSecond(date)</code>实际上调用的是方法1<code>[public volatile void setSecond(Object)]</code>，通过这个方法再去调用<code>public void setSecond(Date)</code>。这个桥方法的实际内容是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.setSecond((java.util.Date) second);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　这样的结果就符合面向对象中多态的特性了，实现了方法的动态绑定。但是，这样的做法给我们带来了一种错觉，就认为<code>public void setSecond(Date)</code>覆写了泛型类的<code>public void setSecond(Object)</code>【其实也不是重写，二者方法参数都不同】，如果我们在DateInterval中增加一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">  System.out.println(<span class="string">"覆写超类方法！"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    编译器会报如下错误：<code>Name clash: The method setSecond(Object) of type DateInter has the same erasure as setSecond(T) of type Pair&lt;T&gt; but doesn&#39;t override it.</code>即，同一个方法不能被重写两次。</p>
<p>​    为了实现多态，我们知道方法3也是由编译器生成的桥方法。方法擦除带来的第二个问题就是：<strong>由编译器生成的桥方法<code>public volatile java.lang.Object getSecond()</code>方法和<code>public java.util.Date getSecond()</code> 方法，从方法签名的角度看是两个完全相同的方法，它们怎么可以共存呢？ </strong>如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情。 </p>
</li>
<li><p>泛型类型变量不能是基本数据类型</p>
<p>​    <strong>类型参数不能是基本类型。</strong>也就是说，没有<code>ArrayList&lt;double&gt;</code>，只有<code>ArrayList&lt;Double&gt;</code>。因为当类型擦除后，ArrayList的原始类型变为Object，但是Object类型不能存储<code>double值</code>，只能<code>引用Double</code>的值。 </p>
</li>
<li><p>转型和警告</p>
<p>使用<strong>带有泛型类型参数的转型或 instanceof 不会有任何效果<em>**</em></strong>，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedSizeStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> Object[] storage;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixedSizeStack</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        storage = <span class="keyword">new</span> Object[size];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</div><div class="line">        storage[index++] = item;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//Warnning: Unchecked cast from Object to T</span></div><div class="line">        <span class="keyword">return</span> (T) storage[--index];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericCast</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        FixedSizeStack&lt;String&gt; strings = <span class="keyword">new</span> FixedSizeStack&lt;String&gt;(SIZE);</div><div class="line">        <span class="keyword">for</span> (String s : <span class="string">"A B C D E F G H I J"</span>.split(<span class="string">" "</span>))</div><div class="line">            strings.push(s);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</div><div class="line">            String s = strings.pop();</div><div class="line">            System.out.print(s + <span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　<strong>由于擦除的原因，T 被擦除到它的第一个边界 Object，因此pop()实际上只是将Object转型为Object。换句话说，pop()方法实际上并没有执行任何转型。</strong></p>
</li>
<li><p><strong>任何在运行时需要知道确切类型信息的操作都将无法工作</strong></p>
<ul>
<li><p><strong>instanceof操作</strong> 的右操作数不能带有泛型类型参数； </p>
</li>
<li><p><strong>new 操作 :</strong>可以 new 泛型类型(eg: ArrayList,…)，但不能 new 泛型参数(T,…)； </p>
</li>
<li><p><strong>泛型数组 :</strong>不可以创建带有泛型类型参数的数组（<code>若需要收集参数化类型对象，可以直接使用 ArrayList：ArrayList&lt;Pair&lt;String&gt;&gt;最安全且有效。</code>）； </p>
</li>
<li><p><strong>转型 :</strong>带有泛型类型参数的转型不会有任何效果；</p>
</li>
<li><p>关于由类型擦除引起的 instance of T，new T 和创建数组T 等问题，可以引入<strong>类型标签Class<t></t></strong>来解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> <span class="keyword">extends</span> <span class="title">Building</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTypeCapture</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    Class&lt;T&gt; kind;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassTypeCapture</span><span class="params">(Class&lt;T&gt; kind)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.kind = kind;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> kind.isInstance(arg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        ClassTypeCapture&lt;Building&gt; ctt1 = <span class="keyword">new</span> ClassTypeCapture&lt;Building&gt;(Building.class);</div><div class="line">        System.out.println(ctt1.f(<span class="keyword">new</span> Building()));       <span class="comment">// true</span></div><div class="line">        System.out.println(ctt1.f(<span class="keyword">new</span> House()));       <span class="comment">// true</span></div><div class="line"></div><div class="line">        ClassTypeCapture&lt;House&gt; ctt2 = <span class="keyword">new</span> ClassTypeCapture&lt;House&gt;(House.class);</div><div class="line">        System.out.println(ctt2.f(<span class="keyword">new</span> Building()));       <span class="comment">// true</span></div><div class="line">        System.out.println(ctt2.f(<span class="keyword">new</span> House()));       <span class="comment">// true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
<li><p>实现参数化接口</p>
<p><strong>一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口</strong>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Person implements Comparable&lt;Person&gt;&#123;  ...   &#125;   <span class="comment">// OK</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HonorPerson</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">HonorPerson</span>&gt;</span>&#123;  ...   &#125;       <span class="comment">// Error</span></div></pre></td></tr></table></figure>
<p>​    HonorPerson 类不能编译，因为擦除会将<code>Comparable&lt;Person&gt;</code>和<code>Comparable&lt;HonorPerson&gt;</code>简化为相同的接口 Comparable， 上面的代码意味着重复实现相同的接口。但是，下面的代码可以通过编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Person implements Comparable&#123;  ...   &#125;   <span class="comment">// OK</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HonorPerson</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;  ...   &#125;       <span class="comment">// OK</span></div></pre></td></tr></table></figure>
<p>这种差别在于：编译器对泛型的特别处理方式。</p>
</li>
<li><p>异常中使用泛型的问题</p>
<p>​    <strong>由于类型擦除的原因，将泛型应用于异常是非常受限的。catch 语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。</strong></p>
<ul>
<li><p>不能抛出也不能捕获泛型类的对象</p>
<p>事实上，<code>泛型类扩展Throwable都不合法</code>(Exception是Throwable的子类)。例如：下面的定义将不会通过编译</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;......&#125;</div></pre></td></tr></table></figure>
<p>　　为什么不能扩展Throwable，因为异常都是在运行时捕获和抛出的，而在编译的时候，泛型信息全都会被擦除掉，那么，假设上面的编译可行，那么，再看下面的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;  </div><div class="line">&#125;<span class="keyword">catch</span>(Problem&lt;Integer&gt; e1)&#123;  </div><div class="line">...  </div><div class="line">&#125;<span class="keyword">catch</span>(Problem&lt;Number&gt; e2)&#123;  </div><div class="line">...  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    在运行时，类型信息被擦除后，那么两个地方的catch都变为原始类型Object，那么也就是说，这两个地方的catch变的一模一样,就“相当于”下面的这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;  </div><div class="line">&#125;<span class="keyword">catch</span>(Problem&lt;Object&gt; e1)&#123;  </div><div class="line">...  </div><div class="line">&#125;<span class="keyword">catch</span>(Problem&lt;Object&gt; e2)&#123;  </div><div class="line">...  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　这当然就是不行的, 就好像catch了两个一模一样的普通异常,编译器就不能通过编译一样。</p>
<hr>
</li>
<li><p>不能再catch子句中使用泛型变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span>&#123;  </div><div class="line">        <span class="keyword">try</span>&#123;  </div><div class="line">            ...  </div><div class="line">        &#125;<span class="keyword">catch</span>(T e)&#123; <span class="comment">//编译错误  </span></div><div class="line">            ...  </div><div class="line">        &#125;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>​    因为泛型信息在编译的时候已经变为原始类型，也就是说上面的 T 会变为原始类型Throwable，那么如果可以再catch子句中使用泛型变量，那么，下面的定义呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span>&#123;  </div><div class="line">        <span class="keyword">try</span>&#123;  </div><div class="line">            ...  </div><div class="line">        &#125;<span class="keyword">catch</span>(T e)&#123; <span class="comment">//编译错误  </span></div><div class="line">            ...  </div><div class="line">        &#125;<span class="keyword">catch</span>(IndexOutOfBounds e)&#123;  </div><div class="line">        &#125;                           </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>​    根据异常捕获的原则，一定是子类在前面，父类在后面，那么上面就违背了这个原则。所以java为了避免这样的情况，禁止在catch子句中使用泛型变量。</p>
<hr>
</li>
<li><p>类型变量可以使用在异常声明中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T</span>&#123;  </div><div class="line">    <span class="keyword">try</span>&#123;  </div><div class="line">        ...  </div><div class="line">    &#125;<span class="keyword">catch</span>(Throwable realCause)&#123;  </div><div class="line">        t.initCause(realCause);  </div><div class="line">        <span class="keyword">throw</span> t;   </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>此时，虽然T也会被擦除为Throwable，但由于用在声明中，因此是合法的。</p>
<p>​</p>
</li>
</ul>
</li>
<li><p>类型擦除后的冲突</p>
<p>当泛型类型被擦除后，创建条件不能产生冲突:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;   </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T value)</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>考虑Pair&lt;&gt;:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T value)</span></span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>擦除后变成了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object)</span></span></div></pre></td></tr></table></figure>
<p><code>这与 Object.equals 方法是冲突的</code>！当然，补救的办法是重新命名引发错误的方法。</p>
<p>​</p>
</li>
<li><p>动态类型安全</p>
<p>先看以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckedList</span> </span>&#123; </div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) </div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oldStyleMethod</span><span class="params">(List probablyDogs)</span> </span>&#123;   <span class="comment">//原生List</span></div><div class="line">  probablyDogs.add(<span class="keyword">new</span> Cat()); </div><div class="line">&#125; </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </div><div class="line">  List&lt;Dog&gt; dogs1 = <span class="keyword">new</span> ArrayList&lt;Dog&gt;(); </div><div class="line">  oldStyleMethod(dogs1);   <span class="comment">// Quietly accepts a Cat </span></div><div class="line">  List&lt;Dog&gt; dogs2 = Collections.checkedList( </div><div class="line">    <span class="keyword">new</span> ArrayList&lt;Dog&gt;(), Dog.class); </div><div class="line">  <span class="keyword">try</span> &#123; </div><div class="line">  oldStyleMethod(dogs2);   <span class="comment">// Throws an exception </span></div><div class="line">  &#125; <span class="keyword">catch</span>(Exception e) &#123; </div><div class="line">  System.out.println(e); </div><div class="line">  &#125; </div><div class="line"><span class="comment">// Derived types work fine: </span></div><div class="line">List&lt;Pet&gt; pets = Collections.checkedList( </div><div class="line"><span class="keyword">new</span> ArrayList&lt;Pet&gt;(), Pet.class); </div><div class="line">  pets.add(<span class="keyword">new</span> Dog()); </div><div class="line">  pets.add(<span class="keyword">new</span> Cat()); </div><div class="line">  &#125; </div><div class="line">&#125; <span class="comment">/* Output: </span></div><div class="line">java.lang.ClassCastException: Attempt to insert class typeinfo.pets.Cat </div><div class="line">element into collection with element type class typeinfo.pets.Dog</div></pre></td></tr></table></figure>
<p>​    使用 Collections 的静态方法：<code>checkedCollection( ), checkedList( ), checkedMap( ), checkedSet( ),  checkedSortedMap( ) 和 checkedSortedSet( )</code>可以在运行时便知道罪魁祸首在哪里，而不必等到将对象从容器中取出时。</p>
</li>
</ol>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-05-20</span><i class="fa fa-tag"></i><a href="/categories/java/" title="java" class="tag">java </a><a href="/tags/泛型/" title="泛型" class="tag">泛型 </a><a href="/tags/多态/" title="多态" class="tag">多态 </a><a href="/tags/类型擦除/" title="类型擦除" class="tag">类型擦除 </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://yoursite.com/2017/05/20/java泛型详解/,Forever Young,java泛型详解,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a role="navigation" href="/2017/05/20/变量与对象的关系/" title="变量与对象的关系" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>